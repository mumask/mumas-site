<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meus Apps</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }
    
    #fluidCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      cursor: crosshair;
    }
    
    .help-button {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: all;
      font-size: 1.8rem;
      color: #fff;
      font-weight: bold;
    }
    
    .help-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }
    
    .tutorial-card {
      position: fixed;
      bottom: 80px;
      left: 20px;
      width: 320px;
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 25px;
      z-index: 99;
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .tutorial-card.active {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }
    
    .tutorial-title {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 15px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .tutorial-section {
      margin-bottom: 15px;
    }
    
    .tutorial-section h3 {
      font-size: 0.9rem;
      color: #999;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .tutorial-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .control-key {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .tutorial-text {
      color: #ccc;
      font-size: 0.9rem;
      line-height: 1.6;
      margin-bottom: 10px;
    }
    
    .music-player {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: transform 0.3s;
      pointer-events: all;
    }
    
    .music-player:hover {
      transform: scale(1.05);
    }
    
    /* Rel√≥gio */
    .clock {
      position: fixed;
      top: 30px;
      right: 30px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 12px 20px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: 600;
      color: #fff;
      letter-spacing: 1px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      font-family: 'Courier New', monospace;
    }
    
    .vinyl {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: radial-gradient(circle, #1a1a1a 30%, #333 30%, #1a1a1a 31%, #2a2a2a 50%, #1a1a1a 51%);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      position: relative;
      animation: spin 3s linear infinite;
      animation-play-state: paused;
    }
    
    .vinyl.playing {
      animation-play-state: running;
    }
    
    .vinyl::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 15px;
      height: 15px;
      background: #000;
      border-radius: 50%;
      box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.2);
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .album-cover {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      object-fit: cover;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .menu-button {
      position: fixed;
      top: 30px;
      left: 30px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: all;
    }
    
    .menu-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }
    
    .menu-icon {
      width: 24px;
      height: 18px;
      position: relative;
    }
    
    .menu-icon span {
      position: absolute;
      width: 100%;
      height: 2px;
      background: #fff;
      left: 0;
      transition: all 0.3s;
    }
    
    .menu-icon span:nth-child(1) { top: 0; }
    .menu-icon span:nth-child(2) { top: 8px; }
    .menu-icon span:nth-child(3) { top: 16px; }
    
    .menu-button.active .menu-icon span:nth-child(1) {
      transform: rotate(45deg);
      top: 8px;
    }
    
    .menu-button.active .menu-icon span:nth-child(2) {
      opacity: 0;
    }
    
    .menu-button.active .menu-icon span:nth-child(3) {
      transform: rotate(-45deg);
      top: 8px;
    }
    
    .side-menu {
      position: fixed;
      top: 0;
      left: -400px;
      width: 360px;
      height: 100vh;
      background: rgba(15, 15, 25, 0.98);
      backdrop-filter: blur(40px);
      border-right: 1px solid rgba(255, 255, 255, 0.15);
      z-index: 99;
      transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      overflow-y: auto;
      padding: 100px 35px 35px 35px;
      pointer-events: all;
      box-shadow: 5px 0 30px rgba(0, 0, 0, 0.5);
    }
    
    .side-menu.active {
      left: 0;
    }
    
    .menu-greeting {
      font-size: 2.2rem;
      font-weight: 700;
      margin-bottom: 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.5px;
    }
    
    .menu-subtitle {
      color: #aaa;
      font-size: 1rem;
      margin-bottom: 45px;
      font-weight: 300;
    }
    
    .apps-menu {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .app-link {
      display: flex;
      align-items: center;
      gap: 18px;
      padding: 16px 18px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 16px;
      text-decoration: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid rgba(255, 255, 255, 0.08);
      position: relative;
      overflow: hidden;
    }
    
    .app-link::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s;
    }
    
    .app-link:hover::before {
      left: 100%;
    }
    
    .app-link:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.25);
      transform: translateX(8px) scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    }
    
    .app-link img {
      width: 48px;
      height: 48px;
      border-radius: 13px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .app-link-name {
      color: #fff;
      font-size: 1.15rem;
      font-weight: 600;
      letter-spacing: -0.2px;
    }
    
    .menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 98;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s;
    }
    
    .menu-overlay.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .container {
      position: relative;
      z-index: 1;
      text-align: center;
      padding: 40px 20px;
      pointer-events: none;
    }
    
    h1 {
      font-size: 3.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #a8dadc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: fadeInDown 1s ease-out;
      filter: drop-shadow(0 0 20px rgba(255,255,255,0.3));
      margin-top: -100px;
    }
    
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }
      .side-menu {
        width: 280px;
        left: -280px;
        padding: 80px 20px 20px 20px;
      }
      .menu-greeting {
        font-size: 1.8rem;
      }
      .tutorial-card {
        width: calc(100vw - 40px);
        left: 20px;
        right: 20px;
      }
    }
  </style>
</head>
<body>
  <canvas id="fluidCanvas"></canvas>
  
  <div class="menu-button" id="menuButton">
    <div class="menu-icon">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  
  <div class="menu-overlay" id="menuOverlay"></div>
  
  <div class="side-menu" id="sideMenu">
    <div class="menu-greeting" id="menuGreeting">Bom dia, Murilo!</div>
    <div class="menu-subtitle">Seus apps favoritos</div>
    <div class="apps-menu">
      <a href="https://web.whatsapp.com" target="_blank" class="app-link">
        <img src="https://cdn-icons-png.flaticon.com/512/733/733585.png" alt="WhatsApp">
        <span class="app-link-name">WhatsApp</span>
      </a>
      <a href="https://www.tiktok.com" target="_blank" class="app-link">
        <img src="https://cdn-icons-png.flaticon.com/512/3046/3046122.png" alt="TikTok">
        <span class="app-link-name">TikTok</span>
      </a>
      <a href="https://www.instagram.com" target="_blank" class="app-link">
        <img src="https://cdn-icons-png.flaticon.com/512/174/174855.png" alt="Instagram">
        <span class="app-link-name">Instagram</span>
      </a>
      <a href="https://discord.com" target="_blank" class="app-link">
        <img src="https://cdn-icons-png.flaticon.com/512/2111/2111370.png" alt="Discord">
        <span class="app-link-name">Discord</span>
      </a>
      <a href="https://www.spotify.com" target="_blank" class="app-link">
        <img src="https://cdn-icons-png.flaticon.com/512/174/174872.png" alt="Spotify">
        <span class="app-link-name">Spotify</span>
      </a>
      <a href="https://www.youtube.com" target="_blank" class="app-link">
        <img src="https://cdn-icons-png.flaticon.com/512/1384/1384060.png" alt="YouTube">
        <span class="app-link-name">YouTube</span>
      </a>
    </div>
  </div>
  
  <div class="help-button" id="helpButton">?</div>
  
  <div class="tutorial-card" id="tutorialCard">
    <div class="tutorial-title">Como Jogar</div>
    
    <div class="tutorial-section">
      <h3>Controles do Personagem</h3>
      <div class="tutorial-controls">
        <span class="control-key">‚Üê ‚Üí</span>
        <span class="control-key">A D</span>
      </div>
      <p class="tutorial-text">Mover para esquerda/direita</p>
      
      <div class="tutorial-controls">
        <span class="control-key">‚Üë</span>
        <span class="control-key">W</span>
        <span class="control-key">ESPA√áO</span>
      </div>
      <p class="tutorial-text">Pular</p>
    </div>
    
    <div class="tutorial-section">
      <h3>Poderes Especiais</h3>
      <p class="tutorial-text">üéÅ Colete os power-ups coloridos que aparecem pela tela!</p>
      <p class="tutorial-text">‚ö° Laranja = Velocidade<br>üíú Roxo = Super Pulo<br>üí® Ciano = Voar<br>üå∏ Rosa = Gigante</p>
      <p class="tutorial-text">Cada poder dura 5 segundos!</p>
    </div>
    
    <div class="tutorial-section">
      <h3>Mover Personagem</h3>
      <p class="tutorial-text">üéØ Clique e segure no boneco para arrast√°-lo. Jogue ele para cima e ele sai voando!</p>
    </div>
    
    <div class="tutorial-section">
      <h3>Explos√µes de Cores</h3>
      <p class="tutorial-text">üé® Clique em qualquer lugar da tela para criar explos√µes coloridas!</p>
    </div>
  </div>
  
  <div class="music-player" id="musicPlayer">
    <div class="vinyl" id="vinyl"></div>
    <img src="https://upload.wikimedia.org/wikipedia/en/5/52/Minecraft_Volume_Alpha_cover.jpg" alt="Minecraft Album" class="album-cover" onerror="this.style.background='linear-gradient(135deg, #667eea 0%, #764ba2 100%)'">
  </div>
  
  <audio id="audioPlayer" loop preload="auto">
    <source src="https://files.catbox.moe/1iiedj.mp3" type="audio/mpeg">
  </audio>
  
  <div class="container">
    <h1 id="greeting">Bom dia, Murilo!</h1>
  </div>

  <script>
    const greeting = document.getElementById('greeting');
    const menuGreeting = document.getElementById('menuGreeting');
    const hour = new Date().getHours();
    let greetingText = '';
    
    if(hour >= 5 && hour < 12) greetingText = 'Bom dia, Murilo!';
    else if(hour >= 12 && hour < 18) greetingText = 'Boa tarde, Murilo!';
    else greetingText = 'Boa noite, Murilo!';
    
    greeting.textContent = greetingText;
    menuGreeting.textContent = greetingText;
    
    const menuButton = document.getElementById('menuButton');
    const sideMenu = document.getElementById('sideMenu');
    const menuOverlay = document.getElementById('menuOverlay');
    
    function toggleMenu() {
      menuButton.classList.toggle('active');
      sideMenu.classList.toggle('active');
      menuOverlay.classList.toggle('active');
    }
    
    menuButton.addEventListener('click', toggleMenu);
    menuOverlay.addEventListener('click', toggleMenu);
    
    const helpButton = document.getElementById('helpButton');
    const tutorialCard = document.getElementById('tutorialCard');
    
    helpButton.addEventListener('click', () => {
      tutorialCard.classList.toggle('active');
    });
    
    const canvas = document.getElementById('fluidCanvas');
    const ctx = canvas.getContext('2d');
    
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    const config = {
      velocityDissipation: 0.97,
      densityDissipation: 0.98
    };
    
    class FluidSimulation {
      constructor() {
        this.particles = [];
        this.musicNotes = [];
        this.colors = [
          { r: 147, g: 51, b: 234 },
          { r: 59, g: 130, b: 246 },
          { r: 236, g: 72, b: 153 },
          { r: 34, g: 211, b: 238 },
          { r: 251, g: 146, b: 60 }
        ];
        this.noteSymbols = ['‚ô™', '‚ô´', '‚ô¨', '‚ô©', '‚ô≠', '‚ôÆ', '‚ôØ'];
      }
      
      createMusicNote() {
        const playerPos = {
          x: width - 65,
          y: height - 55
        };
        
        this.musicNotes.push({
          x: playerPos.x + Math.random() * 40 - 20,
          y: playerPos.y,
          vx: (Math.random() - 0.5) * 2,
          vy: -Math.random() * 3 - 2,
          life: 0,
          maxLife: 100,
          symbol: this.noteSymbols[Math.floor(Math.random() * this.noteSymbols.length)],
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.1,
          alpha: 1
        });
      }
      
      createSplat(x, y) {
        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
        const particleCount = 30;
        
        for(let i = 0; i < particleCount; i++) {
          const angle = (Math.PI * 2 * i) / particleCount;
          const speed = Math.random() * 8 + 4;
          
          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0,
            maxLife: Math.random() * 80 + 60,
            size: Math.random() * 60 + 40,
            color: color,
            alpha: 0
          });
        }
      }
      
      update() {
        this.particles = this.particles.filter(p => p.life < p.maxLife);
        this.musicNotes = this.musicNotes.filter(n => n.life < n.maxLife);
        
        this.particles.forEach(p => {
          p.vx *= config.velocityDissipation;
          p.vy *= config.velocityDissipation;
          p.x += p.vx;
          p.y += p.vy;
          
          p.life++;
          if(p.life < 20) {
            p.alpha = p.life / 20;
          } else if(p.life > p.maxLife - 30) {
            p.alpha = (p.maxLife - p.life) / 30;
          } else {
            p.alpha = 1;
          }
        });
        
        this.musicNotes.forEach(n => {
          n.x += n.vx;
          n.y += n.vy;
          n.rotation += n.rotationSpeed;
          n.life++;
          
          if(n.life > n.maxLife - 30) {
            n.alpha = (n.maxLife - n.life) / 30;
          }
        });
      }
      
      draw() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, width, height);
        
        this.particles.forEach(p => {
          const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
          gradient.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.8})`);
          gradient.addColorStop(0.5, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.4})`);
          gradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        this.musicNotes.forEach(n => {
          ctx.save();
          ctx.translate(n.x, n.y);
          ctx.rotate(n.rotation);
          ctx.font = '30px Arial';
          ctx.fillStyle = `rgba(0, 0, 0, ${n.alpha * 0.6})`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
          ctx.shadowBlur = 10;
          ctx.fillText(n.symbol, 0, 0);
          ctx.restore();
        });
      }
    }
    
    class Enemy {
      constructor() {
        this.width = 30;
        this.height = 35;
        this.x = Math.random() * width;
        this.y = 50;
        this.velocityX = (Math.random() - 0.5) * 3;
        this.velocityY = 0;
        this.gravity = 0.6;
        this.speed = 2;
        this.onGround = false;
        this.health = 2;
        this.dead = false;
        this.direction = Math.random() > 0.5 ? 1 : -1;
        this.walkTimer = 0;
      }
      
      update(platforms) {
        if(this.dead) return;
        
        this.velocityY += this.gravity;
        
        this.walkTimer += 0.1;
        this.x += this.direction * this.speed;
        this.y += this.velocityY;
        
        // Wrap around
        if(this.x + this.width < 0) this.x = width;
        if(this.x > width) this.x = -this.width;
        
        this.onGround = false;
        if(this.y + this.height >= height) {
          this.y = height - this.height;
          this.velocityY = 0;
          this.onGround = true;
        }
        
        platforms.forEach(platform => {
          if(this.x + 5 < platform.x + platform.width &&
             this.x + this.width - 5 > platform.x &&
             this.y + this.height > platform.y &&
             this.y + this.height < platform.y + platform.height + 10) {
            
            if(this.velocityY > 0) {
              this.y = platform.y - this.height;
              this.velocityY = 0;
              this.onGround = true;
            }
          }
        });
        
        // Mudar dire√ß√£o aleatoriamente
        if(Math.random() < 0.02) {
          this.direction *= -1;
        }
      }
      
      draw() {
        if(this.dead) return;
        
        // Corpo vermelho
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(this.x + 5, this.y, 20, 22);
        
        // Cabe√ßa
        ctx.fillStyle = '#cc0000';
        ctx.fillRect(this.x + 7, this.y - 8, 16, 10);
        
        // Olhos malvados
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x + 10, this.y - 5, 3, 3);
        ctx.fillRect(this.x + 17, this.y - 5, 3, 3);
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x + 11, this.y - 4, 1, 2);
        ctx.fillRect(this.x + 18, this.y - 4, 1, 2);
        
        // Pernas com anima√ß√£o
        ctx.fillStyle = '#990000';
        const legOffset = Math.sin(this.walkTimer) * 3;
        ctx.fillRect(this.x + 8, this.y + 22, 5, 13 + legOffset);
        ctx.fillRect(this.x + 17, this.y + 22, 5, 13 - legOffset);
        
        // Barra de vida
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(this.x, this.y - 15, this.width, 4);
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(this.x, this.y - 15, (this.width * this.health) / 2, 4);
      }
      
      takeDamage() {
        this.health--;
        if(this.health <= 0) {
          this.dead = true;
          fluid.createSplat(this.x + this.width / 2, this.y + this.height / 2);
        }
      }
      
      checkCollisionWithPlayer(player) {
        return this.x < player.x + player.width &&
               this.x + this.width > player.x &&
               this.y < player.y + player.height &&
               this.y + this.height > player.y;
      }
    }
    
    class PowerUp {
      constructor(type) {
        this.type = type;
        this.x = Math.random() * (width - 100) + 50;
        this.y = Math.random() * (height * 0.6) + 50;
        this.size = 25;
        this.rotation = 0;
        this.bobOffset = Math.random() * Math.PI * 2;
        this.collected = false;
        
        switch(type) {
          case 'speed':
            this.color = { r: 251, g: 146, b: 60 };
            this.symbol = '‚ö°';
            break;
          case 'jump':
            this.color = { r: 147, g: 51, b: 234 };
            this.symbol = '‚¨Ü';
            break;
          case 'fly':
            this.color = { r: 34, g: 211, b: 238 };
            this.symbol = '‚ú®';
            break;
          case 'giant':
            this.color = { r: 236, g: 72, b: 153 };
            this.symbol = '‚≠ê';
            break;
        }
      }
      
      update() {
        this.rotation += 0.02;
        this.bobOffset += 0.05;
      }
      
      draw() {
        const yOffset = Math.sin(this.bobOffset) * 10;
        
        // Aura
        ctx.save();
        ctx.globalAlpha = 0.3;
        const gradient = ctx.createRadialGradient(this.x, this.y + yOffset, 0, this.x, this.y + yOffset, this.size * 2);
        gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.6)`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y + yOffset, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // C√≠rculo do power-up
        ctx.save();
        ctx.translate(this.x, this.y + yOffset);
        ctx.rotate(this.rotation);
        
        ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.8)`;
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // S√≠mbolo
        ctx.font = 'bold 24px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.symbol, 0, 0);
        
        ctx.restore();
      }
      
      checkCollision(player) {
        const dx = this.x - (player.x + player.width / 2);
        const dy = this.y - (player.y + player.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        return distance < this.size + 20;
      }
    }
    
    class Platform {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = fluid.colors[Math.floor(Math.random() * fluid.colors.length)];
      }
      
      draw() {
        ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.4)`;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
        ctx.lineWidth = 3;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        
        const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
        gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.6)`);
        gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(this.x, this.y, this.width, this.height / 2);
      }
    }
    
    class Player {
      constructor() {
        this.width = 30;
        this.height = 40;
        this.x = 100;
        this.y = Math.min(height * 0.7, height - 150);
        this.velocityX = 0;
        this.velocityY = 0;
        this.speed = 5;
        this.jumpPower = 15;
        this.gravity = 0.6;
        this.onGround = false;
        this.facingRight = true;
        this.isDragging = false;
        this.dragOffsetX = 0;
        this.dragOffsetY = 0;
        this.rotation = 0;
        this.targetRotation = 0;
        this.squash = 1;
        this.lastDragX = 0;
        this.lastDragY = 0;
        this.throwVelocityX = 0;
        this.throwVelocityY = 0;
        this.dragHistory = [];
        
        // Poderes
        this.hasPower = false;
        this.powerType = null;
        this.powerColor = null;
        this.powerParticles = [];
        this.speedActive = false;
        this.jumpActive = false;
        this.flyActive = false;
        this.giantActive = false;
        
        // Sistema de vida
        this.health = 3;
        this.maxHealth = 3;
        this.invincible = false;
        this.invincibleTimer = 0;
        this.dead = false;
      }
      
      update(platforms) {
        if(this.dead) return;
        
        if(this.invincible) {
          this.invincibleTimer--;
          if(this.invincibleTimer <= 0) {
            this.invincible = false;
          }
        }
        
        if(this.isDragging) {
          this.velocityX = 0;
          this.velocityY = 0;
          
          // Calcular rota√ß√£o baseada no movimento do arraste
          const dragVelX = this.x - this.lastDragX;
          const dragVelY = this.y - this.lastDragY;
          this.targetRotation = Math.atan2(dragVelY, dragVelX) * 0.3;
          this.rotation += (this.targetRotation - this.rotation) * 0.15;
          
          // Efeito squash
          this.squash = 0.9 + Math.abs(Math.sin(Date.now() * 0.01)) * 0.2;
          
          // Armazenar hist√≥rico para calcular velocidade de arremesso
          this.dragHistory.push({ x: this.x, y: this.y, time: Date.now() });
          if(this.dragHistory.length > 5) this.dragHistory.shift();
          
          this.lastDragX = this.x;
          this.lastDragY = this.y;
          return;
        } else {
          // Retornar √† posi√ß√£o normal
          this.rotation *= 0.85;
          this.squash += (1 - this.squash) * 0.1;
        }
        
        this.velocityY += this.gravity;
        
        this.x += this.velocityX;
        this.y += this.velocityY;
        
        // Rota√ß√£o durante o voo
        if(!this.onGround && Math.abs(this.velocityX) > 2) {
          this.rotation += this.velocityX * 0.02;
        }
        
        this.velocityX *= 0.98;
        
        // Wrap around - ultrapassar bordas
        if(this.x + this.width < 0) {
          this.x = width;
        }
        if(this.x > width) {
          this.x = -this.width;
        }
        
        this.onGround = false;
        if(this.y + this.height >= height) {
          this.y = height - this.height;
          this.velocityY = 0;
          this.onGround = true;
          this.rotation *= 0.7;
        }
        
        platforms.forEach(platform => {
          if(this.x + 5 < platform.x + platform.width &&
             this.x + this.width - 5 > platform.x &&
             this.y + this.height > platform.y &&
             this.y + this.height < platform.y + platform.height + 10) {
            
            if(this.velocityY > 0) {
              this.y = platform.y - this.height;
              this.velocityY = 0;
              this.onGround = true;
              this.rotation *= 0.7;
            }
          }
        });
        
        // Atualizar part√≠culas de poder
        this.powerParticles = this.powerParticles.filter(p => p.life < p.maxLife);
        this.powerParticles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life++;
          p.alpha = 1 - (p.life / p.maxLife);
        });
        
        // Criar part√≠culas de poder
        if(this.hasPower && Math.random() > 0.7) {
          this.createPowerParticle();
        }
      }
      
      createPowerParticle() {
        this.powerParticles.push({
          x: this.x + this.width / 2 + (Math.random() - 0.5) * 20,
          y: this.y + this.height / 2 + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          size: Math.random() * 4 + 2,
          life: 0,
          maxLife: 30,
          alpha: 1
        });
      }
      
      activatePower(type) {
        this.hasPower = true;
        this.powerType = type;
        
        switch(type) {
          case 'speed':
            this.speed = 10;
            this.powerColor = { r: 251, g: 146, b: 60 }; // Laranja
            this.speedActive = true;
            setTimeout(() => { 
              this.speed = 5; 
              this.speedActive = false;
              this.checkPowersActive();
            }, 5000);
            break;
          case 'jump':
            this.jumpPower = 25;
            this.powerColor = { r: 147, g: 51, b: 234 }; // Roxo
            this.jumpActive = true;
            setTimeout(() => { 
              this.jumpPower = 15;
              this.jumpActive = false;
              this.checkPowersActive();
            }, 5000);
            break;
          case 'fly':
            this.gravity = 0.2;
            this.powerColor = { r: 34, g: 211, b: 238 }; // Ciano
            this.flyActive = true;
            setTimeout(() => { 
              this.gravity = 0.6;
              this.flyActive = false;
              this.checkPowersActive();
            }, 5000);
            break;
          case 'giant':
            this.width = 50;
            this.height = 70;
            this.powerColor = { r: 236, g: 72, b: 153 }; // Rosa
            this.giantActive = true;
            setTimeout(() => { 
              this.width = 30;
              this.height = 40;
              this.giantActive = false;
              this.checkPowersActive();
            }, 5000);
            break;
        }
      }
      
      checkPowersActive() {
        if(!this.speedActive && !this.jumpActive && !this.flyActive && !this.giantActive) {
          this.hasPower = false;
          this.powerType = null;
          this.powerColor = null;
        } else {
          // Definir cor baseada no poder ativo
          if(this.speedActive) this.powerColor = { r: 251, g: 146, b: 60 };
          else if(this.jumpActive) this.powerColor = { r: 147, g: 51, b: 234 };
          else if(this.flyActive) this.powerColor = { r: 34, g: 211, b: 238 };
          else if(this.giantActive) this.powerColor = { r: 236, g: 72, b: 153 };
        }
      }
      
      deactivatePower() {
        this.hasPower = false;
        this.powerType = null;
        this.powerColor = null;
        this.speed = 5;
        this.jumpPower = 15;
        this.gravity = 0.6;
        this.width = 30;
        this.height = 40;
        this.speedActive = false;
        this.jumpActive = false;
        this.flyActive = false;
        this.giantActive = false;
      }
      
      draw() {
        if(this.dead) return;
        
        // Desenhar part√≠culas de poder
        if(this.hasPower) {
          this.powerParticles.forEach(p => {
            ctx.fillStyle = `rgba(${this.powerColor.r}, ${this.powerColor.g}, ${this.powerColor.b}, ${p.alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          });
          
          // Aura de poder
          ctx.save();
          ctx.globalAlpha = 0.3;
          const gradient = ctx.createRadialGradient(
            this.x + this.width / 2, 
            this.y + this.height / 2, 
            0, 
            this.x + this.width / 2, 
            this.y + this.height / 2, 
            this.width
          );
          gradient.addColorStop(0, `rgba(${this.powerColor.r}, ${this.powerColor.g}, ${this.powerColor.b}, 0.5)`);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 1.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        ctx.save();
        
        const centerX = this.x + this.width / 2;
        const centerY = this.y + this.height / 2;
        
        ctx.translate(centerX, centerY);
        ctx.rotate(this.rotation);
        ctx.scale(this.squash, 1 / this.squash);
        
        // Piscar quando invenc√≠vel
        if(this.invincible && Math.floor(this.invincibleTimer / 5) % 2 === 0) {
          ctx.globalAlpha = 0.5;
        }
        
        ctx.translate(-centerX, -centerY);
        
        // Brilho de poder no corpo
        if(this.hasPower) {
          ctx.shadowColor = `rgb(${this.powerColor.r}, ${this.powerColor.g}, ${this.powerColor.b})`;
          ctx.shadowBlur = 15;
        }
        
        // Corpo
        ctx.fillStyle = this.hasPower ? 
          `rgba(255, 255, 255, 0.9)` : '#fff';
        ctx.fillRect(this.x + 5, this.y, 20 * (this.width / 30), 25 * (this.height / 40));
        
        // Cabe√ßa
        ctx.fillStyle = '#ffd1a3';
        ctx.fillRect(this.x + 7 * (this.width / 30), this.y - 8 * (this.height / 40), 16 * (this.width / 30), 10 * (this.height / 40));
        
        ctx.shadowBlur = 0;
        
        // Olhos
        ctx.fillStyle = '#000';
        if(this.isDragging) {
          ctx.fillRect(this.x + 10, this.y - 6, 4, 1);
          ctx.fillRect(this.x + 11, this.y - 7, 2, 3);
          ctx.fillRect(this.x + 16, this.y - 6, 4, 1);
          ctx.fillRect(this.x + 17, this.y - 7, 2, 3);
        } else {
          if(this.facingRight) {
            ctx.fillRect(this.x + 15 * (this.width / 30), this.y - 5 * (this.height / 40), 3, 3);
          } else {
            ctx.fillRect(this.x + 12 * (this.width / 30), this.y - 5 * (this.height / 40), 3, 3);
          }
        }
        
        // Pernas
        ctx.fillStyle = this.hasPower && this.powerType === 'speed' ? 
          `rgb(${this.powerColor.r}, ${this.powerColor.g}, ${this.powerColor.b})` : '#4169e1';
        
        if(this.isDragging) {
          const swing = Math.sin(Date.now() * 0.005) * 3;
          ctx.fillRect(this.x + 8 + swing, this.y + 25 * (this.height / 40), 6 * (this.width / 30), 15 * (this.height / 40));
          ctx.fillRect(this.x + 16 - swing, this.y + 25 * (this.height / 40), 6 * (this.width / 30), 15 * (this.height / 40));
        } else {
          ctx.fillRect(this.x + 8, this.y + 25 * (this.height / 40), 6 * (this.width / 30), 15 * (this.height / 40));
          ctx.fillRect(this.x + 16, this.y + 25 * (this.height / 40), 6 * (this.width / 30), 15 * (this.height / 40));
        }
        
        ctx.restore();
        
        // Barra de vida
        const barWidth = 40;
        const barHeight = 5;
        const barX = this.x + this.width / 2 - barWidth / 2;
        const barY = this.y - 20;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        const healthColor = this.health === 3 ? '#00ff00' : this.health === 2 ? '#ffff00' : '#ff0000';
        ctx.fillStyle = healthColor;
        ctx.fillRect(barX, barY, (barWidth * this.health) / this.maxHealth, barHeight);
      }
      
      takeDamage() {
        if(this.invincible || this.dead) return;
        
        this.health--;
        this.invincible = true;
        this.invincibleTimer = 60; // 1 segundo de invencibilidade
        
        if(this.health <= 0) {
          this.die();
        }
      }
      
      die() {
        this.dead = true;
        fluid.createSplat(this.x + this.width / 2, this.y + this.height / 2);
        setTimeout(() => this.respawn(), 2000);
      }
      
      respawn() {
        this.dead = false;
        this.health = this.maxHealth;
        this.x = 100;
        this.y = Math.min(height * 0.7, height - 150);
        this.velocityX = 0;
        this.velocityY = 0;
        this.invincible = true;
        this.invincibleTimer = 90;
        fluid.createSplat(this.x + this.width / 2, this.y + this.height / 2);
      }
      
      isPointInside(x, y) {
        return x >= this.x && x <= this.x + this.width &&
               y >= this.y && y <= this.y + this.height;
      }
      
      startDrag(mouseX, mouseY) {
        this.isDragging = true;
        this.dragOffsetX = mouseX - this.x;
        this.dragOffsetY = mouseY - this.y;
        this.lastDragX = this.x;
        this.lastDragY = this.y;
        this.dragHistory = [{ x: this.x, y: this.y, time: Date.now() }];
      }
      
      drag(mouseX, mouseY) {
        if(this.isDragging) {
          this.x = mouseX - this.dragOffsetX;
          this.y = mouseY - this.dragOffsetY;
          
          if(this.x < 0) this.x = 0;
          if(this.x + this.width > width) this.x = width - this.width;
          if(this.y < 0) this.y = 0;
          if(this.y + this.height > height) this.y = height - this.height;
        }
      }
      
      stopDrag() {
        if(this.isDragging && this.dragHistory.length > 1) {
          // Calcular velocidade de arremesso
          const first = this.dragHistory[0];
          const last = this.dragHistory[this.dragHistory.length - 1];
          const timeDiff = (last.time - first.time) / 1000;
          
          if(timeDiff > 0) {
            this.velocityX = ((last.x - first.x) / timeDiff) * 0.3;
            this.velocityY = ((last.y - first.y) / timeDiff) * 0.3;
            
            // Limitar velocidade m√°xima
            const maxVel = 20;
            if(Math.abs(this.velocityX) > maxVel) this.velocityX = maxVel * Math.sign(this.velocityX);
            if(Math.abs(this.velocityY) > maxVel) this.velocityY = maxVel * Math.sign(this.velocityY);
            
            // Ativar c√¢mera se jogou com for√ßa
            const throwForce = Math.sqrt(this.velocityX * this.velocityX + this.velocityY * this.velocityY);
            if(throwForce > 8) {
              cameraFollowing = true;
            }
          }
        }
        
        this.isDragging = false;
        this.dragHistory = [];
      }
      
      moveLeft() {
        if(!this.isDragging) {
          this.velocityX = -this.speed;
          this.facingRight = false;
        }
      }
      
      moveRight() {
        if(!this.isDragging) {
          this.velocityX = this.speed;
          this.facingRight = true;
        }
      }
      
      jump() {
        if(this.onGround && !this.isDragging) {
          this.velocityY = -this.jumpPower;
        }
      }
    }
    
    const fluid = new FluidSimulation();
    const player = new Player();
    const powerUps = [];
    const enemies = [];
    
    // Spawnar inimigos
    function spawnEnemy() {
      enemies.push(new Enemy());
    }
    
    // Criar inimigos iniciais
    setInterval(() => {
      if(enemies.filter(e => !e.dead).length < 5) {
        spawnEnemy();
      }
    }, 5000);
    
    spawnEnemy();
    spawnEnemy();
    
    // Sistema de c√¢mera
    let cameraX = 0;
    let cameraY = 0;
    let targetCameraX = 0;
    let targetCameraY = 0;
    const cameraSmoothing = 0.08;
    let cameraFollowing = false;
    
    // Criar power-ups iniciais
    function spawnPowerUp() {
      const types = ['speed', 'jump', 'fly', 'giant'];
      const type = types[Math.floor(Math.random() * types.length)];
      powerUps.push(new PowerUp(type));
    }
    
    // Spawnar power-ups periodicamente
    setInterval(() => {
      if(powerUps.filter(p => !p.collected).length < 3) {
        spawnPowerUp();
      }
    }, 8000);
    
    // Criar alguns power-ups iniciais
    spawnPowerUp();
    spawnPowerUp();
    
    function createPlatforms() {
      const baseHeight = Math.min(height * 0.8, height - 100);
      return [
        new Platform(150, baseHeight, 200, 18),
        new Platform(450, baseHeight - 120, 180, 18),
        new Platform(80, baseHeight - 200, 150, 18),
        new Platform(350, baseHeight - 280, 200, 18),
        new Platform(600, baseHeight - 80, 160, 18),
        new Platform(250, baseHeight - 360, 180, 18),
        new Platform(550, baseHeight - 220, 140, 18),
        new Platform(width - 250, baseHeight - 150, 170, 18)
      ];
    }
    
    let platforms = createPlatforms();
    
    const keys = {};
    
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      
      if((e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w' || e.key === 'W') && !player.isDragging) {
        e.preventDefault();
        player.jump();
      }
      
      // Ativar poderes com teclas num√©ricas
      if(e.key === '1') player.activatePower('speed');
      if(e.key === '2') player.activatePower('jump');
      if(e.key === '3') player.activatePower('fly');
      if(e.key === '4') player.activatePower('giant');
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });
    
    let mouseDown = false;
    let mouseX = 0;
    let mouseY = 0;
    
    canvas.addEventListener('mousedown', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      
      if(player.isPointInside(mouseX, mouseY)) {
        player.startDrag(mouseX, mouseY);
        mouseDown = true;
      } else {
        fluid.createSplat(mouseX, mouseY);
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      
      if(mouseDown && player.isDragging) {
        player.drag(mouseX, mouseY);
      }
    });
    
    canvas.addEventListener('mouseup', () => {
      mouseDown = false;
      player.stopDrag();
    });
    
    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
      
      if(player.isPointInside(mouseX, mouseY)) {
        e.preventDefault();
        player.startDrag(mouseX, mouseY);
        mouseDown = true;
      } else {
        e.preventDefault();
        fluid.createSplat(mouseX, mouseY);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
      
      if(mouseDown && player.isDragging) {
        e.preventDefault();
        player.drag(mouseX, mouseY);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', () => {
      mouseDown = false;
      player.stopDrag();
    });
    
    const audio = document.getElementById('audioPlayer');
    const musicPlayer = document.getElementById('musicPlayer');
    const vinyl = document.getElementById('vinyl');
    let isPlaying = false;
    let noteInterval;
    
    function togglePlay() {
      if(isPlaying) {
        audio.pause();
        vinyl.classList.remove('playing');
        clearInterval(noteInterval);
        isPlaying = false;
      } else {
        audio.play().then(() => {
          vinyl.classList.add('playing');
          isPlaying = true;
          noteInterval = setInterval(() => {
            if(Math.random() > 0.3) {
              fluid.createMusicNote();
            }
          }, 300);
        }).catch(err => {
          console.log('Erro ao tocar √°udio:', err);
        });
      }
    }
    
    musicPlayer.addEventListener('click', togglePlay);
    
    function animate() {
      if(keys['ArrowLeft'] || keys['a'] || keys['A']) player.moveLeft();
      if(keys['ArrowRight'] || keys['d'] || keys['D']) player.moveRight();
      
      player.update(platforms);
      
      // Atualizar c√¢mera APENAS quando jogador est√° voando
      const playerSpeed = Math.sqrt(player.velocityX ** 2 + player.velocityY ** 2);
      
      if(cameraFollowing) {
        targetCameraX = -(player.x + player.width / 2 - width / 2);
        targetCameraY = -(player.y + player.height / 2 - height / 2);
        
        // Desativar c√¢mera quando jogador parar
        if(playerSpeed < 2 && player.onGround) {
          cameraFollowing = false;
        }
      } else {
        // Retornar ao centro
        targetCameraX = 0;
        targetCameraY = 0;
      }
      
      cameraX += (targetCameraX - cameraX) * cameraSmoothing;
      cameraY += (targetCameraY - cameraY) * cameraSmoothing;
      
      // Atualizar inimigos
      enemies.forEach((enemy, index) => {
        enemy.update(platforms);
        
        // Colis√£o com jogador
        if(!enemy.dead && enemy.checkCollisionWithPlayer(player)) {
          player.takeDamage();
        }
        
        // Colis√£o com poderes do jogador (jogador grande mata inimigos)
        if(!enemy.dead && player.giantActive && enemy.checkCollisionWithPlayer(player)) {
          enemy.takeDamage();
        }
        
        // Remover inimigos mortos h√° muito tempo
        if(enemy.dead && Math.random() < 0.001) {
          enemies.splice(index, 1);
        }
      });
      
      // Atualizar power-ups
      powerUps.forEach((powerUp, index) => {
        if(!powerUp.collected) {
          powerUp.update();
          
          if(powerUp.checkCollision(player)) {
            powerUp.collected = true;
            player.activatePower(powerUp.type);
            fluid.createSplat(powerUp.x, powerUp.y);
            setTimeout(() => powerUps.splice(index, 1), 100);
          }
        }
      });
      
      fluid.update();
      fluid.draw();
      
      ctx.save();
      ctx.translate(cameraX, cameraY);
      
      platforms.forEach(p => p.draw());
      
      powerUps.forEach(p => {
        if(!p.collected) p.draw();
      });
      
      enemies.forEach(e => e.draw());
      
      player.draw();
      
      ctx.restore();
      
      requestAnimationFrame(animate);
    }
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
    
    animate();
    
    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      platforms = createPlatforms();
      player.y = Math.min(height * 0.7, height - 150);
    });
  </script>
</body>
</html>
